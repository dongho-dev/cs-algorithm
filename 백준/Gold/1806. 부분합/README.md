# [Gold IV] 부분합 - 1806 

[문제 링크](https://www.acmicpc.net/problem/1806) 

### 성능 요약

메모리: 42168 KB, 시간: 112 ms

### 분류

누적 합, 두 포인터

### 제출 일자

2025년 4월 12일 22:55:29

### 문제 설명

<p>10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N (10 ≤ N < 100,000)과 S (0 < S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.</p>

### 출력 

 <p>첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.</p>

## ❗ 문제 요약

10000 이하의 자연수로 이루어진 길이 N 수열 주어짐.
이 수열에서 연속된 수들의 부분합 중에 합이 S 이상인 것들 중
가장 짧은 부분합의 길이를 구해야 함.

## 🧠 접근 전략

시간제한 0.5초, N 개수가 10만개이므로 O(N^2)는 시간 초과.
O(N log N) 이하로 로직 작성.

연속된 수의 부분합 중 S보다 크면서 부분합 길이의 최소값을 구해야 함.

-> 투 포인터 알고리즘은 이중 for문을
st와 en이 끝에서 끝까지 한번만 이동해 O(2N)으로 변환하는 알고리즘임.
불필요한 반복문 사용 X, 정렬 여부 확인

## ⚠ 시행착오 & 관점 전환

en = 0, 1, 2 ....
for st in range(N):
        partSum = 0

        for st in range(en):
            partSum += A[st]        
    
        if partSum > S:
            minimum = min(partSum, minimum)

        if partSum == S:
            minimum = S
            break
    
        en += 1

위 코드를 처음 짜고, 아래로 합치니 시간 초과가 예상되는 코드가 나온다.   
불가능하다면 0을 출력해야 한다는 건, 최악의 경우 전체 탐색을 해야 할 수도.

for en in range(N):
    for st in range(N):
        partSum = 0

        for st in range(en):
            partSum += A[st]        
    
        if partSum > S:
            minimum = min(partSum, minimum)

        if partSum == S:
            minimum = S
            break
    
        en += 1

        
! '연속'된 수의 부분합이어서 정렬해서는 안되는 것이었음.
수 고르기(2230) 문제는 두 수를 자유롭게 골라고 되며,
연속하지 않아도 되기에 정렬이 가능했던 것. 착각하지 말아야 함.

문제에서 정렬이 가능한지 먼저 확인하고 접근해야 함.

문제 조건도 다시 한번 읽어서
"부분합"인지 "부분합의 최소 길이"인지 확인.

연속된 수이기에 정렬할 수 없으니, S보다 크면서 최소값인 S를 만나도 탈출 X

S보다 부분합 partSum이 작으면 en 값을 1씩 더해서 길이 늘리면서 부분합 탐색.
인덱스 범위 벗어나지 않도록 예외 처리.

S보다 부분합이 크면 부분합의 길이(en - st + 1)를 현재 상태의 최소값과 비교해서 갱신.
수열의 뒷부분에 조건을 만족하면서 더 짧은 길이의 부분합이 존재할 수 있기 때문에
맨 앞의 st에 해당하는 값을 부분합에서 빼고 st를 뒤로 한칸 밀어서 구간을 줄이고, 남아있는 부분합을 마저 탐색한다.

## ❗ 추가 개념 & 지식

투 포인터 알고리즘을 사용하는 문제는 정렬이 가능한지 먼저 확인하자.

