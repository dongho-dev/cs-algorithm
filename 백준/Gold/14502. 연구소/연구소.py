import sys
from itertools import combinations
from collections import deque

N, M = map(int, sys.stdin.readline().split())
lab = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

empty = []
virus = []

for i in range(N):
    for j in range(M):
        if lab[i][j] == 0:
            empty.append((i, j))
        elif lab[i][j] == 2:
            virus.append((i, j))

directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def spread_virus(sim_lab):
    q = deque(virus)
    while q:
        x, y = q.popleft()
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < N and 0 <= ny < M and sim_lab[nx][ny] == 0:
                sim_lab[nx][ny] = 2
                q.append((nx, ny))
    return sum(row.count(0) for row in sim_lab)

max_safe = 0
for walls in combinations(empty, 3):
    sim_lab = [row[:] for row in lab]
    for x, y in walls:
        sim_lab[x][y] = 1
    safe_area = spread_virus(sim_lab)
    max_safe = max(max_safe, safe_area)

print(max_safe)


'''

14502 연구소

문제
인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.

연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 

일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.

2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.

2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.

2 1 0 0 1 1 0
1 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 1 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
바이러스가 퍼진 뒤의 모습은 아래와 같아진다.

2 1 0 0 1 1 2
1 0 1 0 1 2 2
0 1 1 0 1 2 2
0 1 0 0 0 1 2
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0
벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.

연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.

입력
첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)

둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2(바이러스)의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.

빈 칸의 개수는 3개 이상이다.

출력
첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.
 
'''



'''

조건 
시간 제한: 2초
첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)
둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 
2(바이러스)의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.
빈 칸의 개수는 3개 이상이다.
일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.

---

첫째 줄에서 sys.stdin.readline()으로 N과 M을 입력받는다.
최대 64개의 좌표값을 가진다.
2차원 배열 맵에 좌표값을 입력받아서 저장.
이 2차원 맵의 원본은 불변. 시뮬레이션의 경우 원본을 복사해서 사용.

2차원 배열 맵에 좌표값을 입력받아서 저장한다.
이후, 감염 시뮬레이션과 벽 설치를 효율적으로 캐싱하기 위해,
0인 칸(빈 칸)과 2인 칸(바이러스 위치)을 각각 리스트에 따로 저장한다.

벽 세우는 함수 생성:
어떻게 벽 3개를 세워야 하는가?
최악의 경우의 수: (64C3) = 약 4만
벽을 3개 세운다.(3개 좌표의 좌표값을 0에서 1로 변경)
모든 경우의 수에 대해 벽을 세우고, BFS 탐색시 시간 초과의 가능성이 있나? 
40000 * O(NM) = ~= 3000000이므로 통과. 브루트포스 방식으로 진행


좌표값 검사 함수 생성.
:
모든 좌표값을 검사한다. BFS 탐색.
초기화 단계
맵 전체를 검사하여, 값이 2인 모든 좌표들을 찾아서 큐에 삽입한다.
이 큐는 바이러스가 퍼질 위치들을 담고 있으며, 처음에는 모든 바이러스의 위치가 들어 있다.

탐색 시작
큐에서 좌표 하나를 꺼낸다. (이 좌표는 현재 바이러스가 존재하는 위치이다)

상하좌우 인접 좌표 확인
꺼낸 좌표의 상, 하, 좌, 우에 해당하는 인접한 4칸을 검사한다.

감염 조건 검사
인접한 칸이 맵의 범위 안에 있고, 빈 칸(0) 이라면:

해당 칸을 2로 바꾸어 감염 처리한다.

그리고 그 좌표를 다시 큐에 삽입한다. (이 위치에서 다시 전염이 확산될 수 있도록)

반복
큐가 빌 때까지, 위 과정을 반복한다.
이 과정을 통해, 모든 바이러스가 동시다발적으로 확산되는 시뮬레이션이 완성된다.

감염 종료
큐가 비면, 더 이상 전염될 수 있는 칸이 없는 것이므로 감염 시뮬레이션이 종료된다.
이후에는 맵을 검사하여 0의 개수(안전 구역 크기)를 계산하면 된다.

모든 벽을 세우는 케이스에 대해 반복할 시뮬레이션:
2차원 맵이므로, 좌표값을 list comprehension 방식으로 복사해서 새 맵을 만든다.
만들고 벽 세우는 함수 -> 좌표값 검사 함수 순으로 진행하고
안전 영역의 크기: 남아있는 좌표값 중 0의 개수
결과(안전 영역의 크기) 변수를 업데이트

결과를 출력한다.

'''

