import sys

# 첫째 줄에 두 정수 N, M이 주어진다. 
N, M = map(int, sys.stdin.readline().strip().split())

# 다음 N개의 줄에는 차례로 A[1], A[2], …, A[N]이 주어진다.
A = []
for _ in range(N): # 1 ≤ N ≤ 100,000
    i = int(sys.stdin.readline().strip())
    A.append(i)

A.sort()

en = 0
minimum = float('inf')

for st in range(N):
    while en < N and (A[en] - A[st]) < M: 
        en += 1

    if en == N: 
        break

    if (A[en] - A[st]) == M:
        minimum = M
        break

    minimum = min(minimum, (A[en] - A[st]))

# 첫째 줄에 M 이상이면서 가장 작은 차이를 출력한다. 
# 항상 차이가 M 이상인 두 수를 고를 수 있다.
print(minimum)

'''
# 2230 수 고르기

두 수 A, B를 고르는데, (같을 수도 있음)
이 차이가 M 이상이면서 가장 작은 경우를 구해야 함.

수열이 1~5까지 있으면
M이 3이라고 가정하면

1, 4 / 1, 5 / 2, 5 3가지 경우가 차이가 M(3) 이상이다.
그중에 가장 작은 경우 (1,4 / 2,5) 의 차이를 출력해야 함. 여기선 3

# 입력 테스트 
print("입력 테스트")
print(N, M)
print(A)
입력 테스트 통과

두 개를 어떻게 골라야 할까?

시간 제한 2초인데 N이 10만까지니까 O(N^2)로 하면 100% 시간 초과.
O(N log N) 이하로 작성해야 하니 이중 for문으로 브루트포스하는 방법은 배제.

근데 결국 M보다 작은 경우가 아니라면 모두 검증해야 함. 
M과 동일한 값이 나오지 않는 이상. 탐색 안한 범위에서 M과 동일한 값이 나오는 경우가 있을 수 있음.

그러면 O(N log N) 이하로 M과 동일한 차이를 가지는 값이 나올때까지 탐색을 해야함.

어떻게?

이분 탐색 or 투 포인터 알고리즘 사용해야 함.
여기선 투 포인터로.

정렬해야  포인터가 오른쪽으로 이동할수록 차이 값이 커지기에 가장 적은 차이값을 구하고 나면
뒤 값은 무시하고 다음 반복으로 넘어갈 수 있음. 투 포인터로 풀기 전에 먼저 정렬해야 함.

차이값이 M보다 작으면 en 값 갱신,
같으면 minimum = N 처리하고 탈출
크면 minimum 값 비교해서 갱신.
st값 올려가면서 진행.

en = n인 경우 바로 탈출할 수 있게 예외처리



'''